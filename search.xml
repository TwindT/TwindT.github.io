<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Codeforces1004(Div2 A-E)</title>
    <url>/2025/02/12/Codeforces1004/</url>
    <content><![CDATA[<p>感觉这场整体都很神秘, 很符合cf特色</p>
<h3 id="A-Adjacent-Digit-Sums"><a href="#A-Adjacent-Digit-Sums" class="headerlink" title="A. Adjacent Digit Sums"></a>A. Adjacent Digit Sums</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2067/problem/A" >https://codeforces.com/contest/2067/problem/A<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>首先我们想到, 对一个数加 1 在不考虑进位时体现在数位和上其实也是加 1, 所以如果 y &#x3D;&#x3D; x + 1 此时一定满足;</p>
<p>对于 y !&#x3D; x + 1 时, n至少个位是 9 , 这样加1出现进位才能使得数位和差大于 1;</p>
<p>这样 x 就会比 y 大 i * 9 - 1 (i为未知数) 我们只用枚举 i 即可.</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y == x + <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= x / <span class="number">9</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y == x - <span class="number">9</span> * i + <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="B-Two-Large-Bags"><a href="#B-Two-Large-Bags" class="headerlink" title="B. Two Large Bags"></a>B. Two Large Bags</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2067/problem/B" >https://codeforces.com/contest/2067/problem/B<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>通过题目我们可以知道, 对于大数无法平分给两个数组的情况, 我们可以利用小数加 1 这个条件来解决;</p>
<p>对于个数只有 0 或者 2 的元素我们无法再拆分, 而对于大于 2 的元素, 因为要满足加 1 这个条件我们必须剩两个平分两个数组,</p>
<p>所以我们贪心, 将剩下的全部加到后一个元素上, 最终如果剩下的数量为偶数则满足条件.</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">        mp[v[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp[i] == <span class="number">0</span> || mp[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mp[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mp[i + <span class="number">1</span>] += mp[i] - <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mp[n + <span class="number">1</span>] % <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="C-Devyatkino"><a href="#C-Devyatkino" class="headerlink" title="C. Devyatkino"></a>C. Devyatkino</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2067/problem/C" >https://codeforces.com/contest/2067/problem/C<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>根据题目我们知道, 我们每次操作就是加上 9, 99, 999 … 其中一个;</p>
<p>仔细观察后我们能发现, 不管加上上述提到的那个数, 结果的个位都会-1, 因此我们就能在很有限的操作次数下得到结果;</p>
<p>考虑到可能出现进位或者其他数位与 9 相加得到 7 的情况, 我们只要暴力枚举 9, 99, 999 … 即可.</p>
<p>而由于 n 最大为1e9, 所以我们把枚举上限设置到小于1e9.</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否存在数位为7</span></span><br><span class="line">    <span class="keyword">auto</span> check7 = [&amp;] (ll x) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            <span class="type">int</span> mid = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">7</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ll x = <span class="number">9</span>;</span><br><span class="line">    ll ans = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &lt; <span class="number">1e9</span>) &#123;</span><br><span class="line">        ll num = n;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check7</span>(num)) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, (num - n) / x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num += x;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * <span class="number">10</span> + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="D-Object-Identification"><a href="#D-Object-Identification" class="headerlink" title="D. Object Identification"></a>D. Object Identification</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2067/problem/D" >https://codeforces.com/contest/2067/problem/D<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>根据题目我们能得到一些关键信息:</p>
<ul>
<li>对于对象 A 如果没有路径则会返回 0 , 而因为题目限制对象 B 是不会返回 0 的, 我们可以以此区分 A, B;</li>
<li>数组 x[i] 的范围是 1-n ,那么数组x可以分为两种情况:一种是 1-n 全部出现, 另一种没有全部出现;</li>
</ul>
<p>首先对于全部出现的情况, 我们可以选择相差最大的两个x(只能是 1 和 n), 进行两次询问, 正着一次, 反着一次,</p>
<p>如果是 A 对象, 那么在路径最长的情况下两次询问结果中只可能有一次为 n - 1, 不可能两次都是 n - 1;</p>
<p>对于另一种情况, 那么未出现的数出度为0, 因此我们询问该点和另一个出现过的点, 结果一定为 0.</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        mp[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> query = [&amp;] (<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;?&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        cin &gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mp.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">query</span>(mp[<span class="number">1</span>], mp[n]) &gt;= n - <span class="number">1</span> &amp;&amp; <span class="built_in">query</span>(mp[n], mp[<span class="number">1</span>]) &gt;= n - <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;! B&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;! A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)  &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp[i]) x = i;</span><br><span class="line">            <span class="keyword">else</span> y = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">query</span>(y, x)) cout &lt;&lt; <span class="string">&quot;! B&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;! A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="E-White-Magic"><a href="#E-White-Magic" class="headerlink" title="E. White Magic"></a>E. White Magic</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2067/problem/E" >https://codeforces.com/contest/2067/problem/E<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>观察到如果序列中不存在 0 那么答案显然为 n;</p>
<p>假设出现了 0 那么一定是保留最左边的 0 将剩余的 0 全部删除最优, 这样保证了 0 右边的是全部满足题设条件的;</p>
<p>此时我们只用判读左边是否满足题设条件, 如果不满足我们就将剩下的一个 0 删除即可;</p>
<p>我们可以预处理出来每个位置的 mex, 然后在维护最小值的同时判断即可.</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">0</span> &amp;&amp; flag) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">0</span>) flag = <span class="number">1</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理mex</span></span><br><span class="line">    <span class="type">int</span> len = v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getmex</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] &lt; n) st[v[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mex = getmex[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (mex &lt; n &amp;&amp; st[mex]) mex++;</span><br><span class="line"></span><br><span class="line">        getmex[i] = mex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mi = INF;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        mi = <span class="built_in">min</span>(mi, v[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mi &lt; getmex[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() - <span class="number">1</span> + flag &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces1003(Div4 A-F)</title>
    <url>/2025/02/10/Codeforces1003/</url>
    <content><![CDATA[<h3 id="A-Skibidus-and-Amog’u"><a href="#A-Skibidus-and-Amog’u" class="headerlink" title="A. Skibidus and Amog’u"></a>A. Skibidus and Amog’u</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2065/problem/A" >https://codeforces.com/contest/2065/problem/A<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>没有什么特别的,根据题目直接模拟即可</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len - <span class="number">2</span>;i++) cout &lt;&lt; s[i];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="B-Skibidus-and-Ohio"><a href="#B-Skibidus-and-Ohio" class="headerlink" title="B. Skibidus and Ohio"></a>B. Skibidus and Ohio</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2065/problem/B" >https://codeforces.com/contest/2065/problem/B<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>我们发现如果至少存在一组使得 s[i] &#x3D;&#x3D; s[i + 1] 那么我们就可以一直操作直到剩最后一个字母</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; len &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="C-Skibidus-and-Fanum-Tax-C1-C2"><a href="#C-Skibidus-and-Fanum-Tax-C1-C2" class="headerlink" title="C. Skibidus and Fanum Tax (C1,C2)"></a>C. Skibidus and Fanum Tax (C1,C2)</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2065/problem/C2" >https://codeforces.com/contest/2065/problem/C2<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>由于对每个 a[i] 都可以独立地使用任意一个 b[j] (且可以重复使用),因此对于每个 i,如果我们选择操作,</p>
<p>实际上可以得到任意形如 b − a[i] 的数，其中 b 来自数组 b;</p>
<p>而我们的目标是 “给后面的数留出空间”;因此在满足”至少不比前一个数小”的前提下，越小越好.</p>
<p>一种自然的思路是动态规划:</p>
<ul>
<li><p>1.不操作: 若 a[i] &gt;&#x3D; dp[i - 1], 则可以令 dp[i] &#x3D; a[i].</p>
</li>
<li><p>2.操作: 如果存在某个b使得操作后的值满足b &gt;&#x3D; dp[i - 1] + a[i]那么我们可以从数组 b 中选择满足条件的最小值b(我们记为b*), 这样得到的操作结果是 dp[i] &#x3D; b*-a[i].</p>
</li>
</ul>
<p>最终, 若对某个位置 i 上, 两种选择都不满足条件 (即都无法使 v[i] &gt;&#x3D; dp[i - 1]), </p>
<p>则说明无法构造出一个非递减序列;</p>
<p>否则, 最后存在一种方案使得整个序列非递减.</p>
<p>对于操作选项, 我们需要找到满足 b &gt;&#x3D; dp[i - 1] + a[i] 的最小的 b , </p>
<p>因此我们可以先对数组 b 排序, 再用二分查找来寻找下界.</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dp = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> sen = INF;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= dp) sen = a[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = dp + a[i];</span><br><span class="line">        <span class="keyword">auto</span> pos = <span class="built_in">lower_bound</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>(), mid);</span><br><span class="line">        <span class="keyword">if</span> (pos != b.<span class="built_in">end</span>()) sen = <span class="built_in">min</span>(sen, *pos - a[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sen == INF) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp = sen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="D-Skibidus-and-Sigma"><a href="#D-Skibidus-and-Sigma" class="headerlink" title="D. Skibidus and Sigma"></a>D. Skibidus and Sigma</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2065/problem/D" >https://codeforces.com/contest/2065/problem/D<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>由题目所得, 分数的构成是由前缀和来决定, 所以贪心的想法就是把前缀和大的数组放在前面,这样我们就能最大化分数.</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (m + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;PII&gt; sen;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j++) &#123;</span><br><span class="line">            cin &gt;&gt; v[i][j];</span><br><span class="line">            sum += v[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sen.<span class="built_in">push_back</span>(&#123;sum, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(sen.<span class="built_in">begin</span>(), sen.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;PII&gt; ());</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [sum, pos] : sen) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j++) &#123;</span><br><span class="line">            cnt += v[pos][j];</span><br><span class="line">            ans += cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="E-Skibidus-and-Rizz"><a href="#E-Skibidus-and-Rizz" class="headerlink" title="E. Skibidus and Rizz"></a>E. Skibidus and Rizz</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2065/problem/E" >https://codeforces.com/contest/2065/problem/E<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>根据题目, 我们需要关注几个点:</p>
<ul>
<li><p>首先如果 abs(n - m) &gt; k 则无解</p>
</li>
<li><p>其次我们判断 n 和 m 的大小分开处理</p>
</li>
<li><p>然后我们在判断个数更大的数与k的关系 如果小于 k 则无解</p>
</li>
</ul>
<p>现在我们假设 n &gt; m:</p>
<p>我们可以先输出 k 个0, 再输出 k - (n - m) 个 1 这样操作后 0 和 1 的剩余个数就会一样;</p>
<p>从前面我们知道 abs(n - m) &lt;&#x3D; k 那么如果 n - m &lt; k 我们就可以直接 101010 这样交替构造;</p>
<p>如果 n - m &#x3D;&#x3D; k 则 此时只能 010101 这样构造</p>
<p>反之如果 n &lt; m 同理</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(n - m) &gt; k) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;] (<span class="type">char</span> tar, <span class="type">int</span> num1, <span class="type">int</span> num2) -&gt; string &#123;</span><br><span class="line">        string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++) s.<span class="built_in">push_back</span>(tar);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> sen = (tar == <span class="string">&#x27;1&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; k - (num1 - num2);i++) s.<span class="built_in">push_back</span>(sen);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = num1 - k;</span><br><span class="line">        <span class="keyword">if</span> (num1 - num2 &lt; k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">                s.<span class="built_in">push_back</span>(tar);</span><br><span class="line">                s.<span class="built_in">push_back</span>(sen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">                s.<span class="built_in">push_back</span>(sen);</span><br><span class="line">                s.<span class="built_in">push_back</span>(tar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; k) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string ans = <span class="built_in">f</span>(<span class="string">&#x27;0&#x27;</span>, n, m);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; k) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string ans = <span class="built_in">f</span>(<span class="string">&#x27;1&#x27;</span>, m, n);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="F-Skibidus-and-Slay"><a href="#F-Skibidus-and-Slay" class="headerlink" title="F. Skibidus and Slay"></a>F. Skibidus and Slay</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2065/problem/F" >https://codeforces.com/contest/2065/problem/F<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>首先以一个点为中心向四周扩散这种也符合题目要求的简单路径;</p>
<p>假设某条边所连两个点对应值相等,此时为满足条件的最短的路径;</p>
<p>如果并不相等那么我们可以依次判断每个点的所有连边, 例如此时顶点为3(值与后边不同)和他所连的两个点为1, 2值均为5</p>
<p>此时 1 &lt;- 3 -&gt; 2 是满足条件的 我们可以记录对应值出现的个数, 如果个数大于1则满足条件</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edge</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ());</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(u);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a[u] == a[v]) ans[a[u]] = <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : edge[i]) mp[a[c]]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [c, v] : mp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v &gt; <span class="number">1</span>) ans[c] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="G-Skibidus-and-Capping"><a href="#G-Skibidus-and-Capping" class="headerlink" title="G. Skibidus and Capping"></a>G. Skibidus and Capping</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2065/problem/G" >https://codeforces.com/contest/2065/problem/G<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>数论题不做啦</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces1005(Div2 A-D)</title>
    <url>/2025/02/17/Codeforces1005/</url>
    <content><![CDATA[<h3 id="A-Brogramming-Contest"><a href="#A-Brogramming-Contest" class="headerlink" title="A. Brogramming Contest"></a>A. Brogramming Contest</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2064/problem/A" >https://codeforces.com/contest/2064/problem/A<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>如果 s 是以 0 开头那么我们每次只要找到 0, 1 交界的地方进行操作即可;</p>
<p>如果 s 是以 1 开头那么我们需要多进行一次操作把字符串变成以 0 开头的.</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[i + <span class="number">1</span>]) ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="B-Variety-is-Discouraged"><a href="#B-Variety-is-Discouraged" class="headerlink" title="B. Variety is Discouraged"></a>B. Variety is Discouraged</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2064/problem/B" >https://codeforces.com/contest/2064/problem/B<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>删除元素的同时数组长度也会变小;</p>
<p>假设现在某种元素的个数只有 1 个, 我们将其删掉后数组中元素种类和数组长度都减少 1 对于得分其实没有影响;</p>
<p>所以在不操作时的得分已经是最大得分了, 那么我们只需在得分不变的情况下尽可能减少数组长度;</p>
<p>基于上面第一个判断, 我们只要找到一个最大的连续片段, 这个片段中所有元素的个数都为 1;</p>
<p>注意特判一下所有元素个数都为 1 和不为 1 的情况即可.</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">        mp[v[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mxl = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp[v[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!now) now = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (now) &#123;</span><br><span class="line">                <span class="type">int</span> len = i - now;</span><br><span class="line">                <span class="keyword">if</span> (len &gt; mxl) &#123;</span><br><span class="line">                    mxl = len;</span><br><span class="line">                    l = now;</span><br><span class="line">                    r = i - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                now = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (now) &#123;</span><br><span class="line">        <span class="type">int</span> len = n - now + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; mxl) &#123;</span><br><span class="line">            mxl = len;</span><br><span class="line">            l = now;</span><br><span class="line">            r = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mxl == <span class="number">0</span>) cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="C-Remove-the-Ends"><a href="#C-Remove-the-Ends" class="headerlink" title="C. Remove the Ends"></a>C. Remove the Ends</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2064/problem/C" >https://codeforces.com/contest/2064/problem/C<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>现在假设我们任取一个位置 i, 根据题目可以判断:</p>
<p>-这个位置之前的所有负数我们都不能取, 而所有正数都能取到;</p>
<p>-这个位置之后的所有正数我们都不能取, 而所有负数都能取到;</p>
<p>所以我们对数组中的正数做前缀和处理, 负数做后缀和处理, 然后枚举每个位置取 max 即可.</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; v[i];</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">pref</span><span class="params">(n + <span class="number">3</span>)</span>, <span class="title">prez</span><span class="params">(n + <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) prez[i] = prez[i - <span class="number">1</span>] + <span class="built_in">max</span>(<span class="number">0</span>, v[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i--) pref[i] = pref[i + <span class="number">1</span>] + <span class="built_in">max</span>(<span class="number">0</span>, -v[i]);</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) ans = <span class="built_in">max</span>(ans, pref[i] + prez[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="D-Eating"><a href="#D-Eating" class="headerlink" title="D. Eating"></a>D. Eating</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2064/problem/D" >https://codeforces.com/contest/2064/problem/D<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>首先如果两个数最高位相同, 那么异或后最高位会被消掉否则最高位会被保留;</p>
<p>其次是异或运算满足结合律, 即 (a ^ b) ^ c &#x3D; (a ^ c) ^ b ;</p>
<p>所以如果某个数的最高位比 x 低显然我们是可以将其吃掉的, 同时 x 的最高位依然会被保留;</p>
<p>于是我们只要从前找到一个最高位和 x 相等的最大值和 x 进行比较, 如果 x 小于这个数显然不能再往前走了反之继续;</p>
<p>当然这里 x 需要和这个最大值之后的所有元素进行异或, 利用到结合律我们可以预处理出前缀异或数组来计算;</p>
<p>对于找到某个最高位的最大值我们也可以预处理出一个二维 dp 数组 dp[i][j] 表示前 i 个数 最高位至少为 j 的最大值的位置.</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">pre</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">        pre[i] = w[i] ^ pre[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前 i 个数中最高位至少为 j 的最大位置</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (<span class="number">30</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">30</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; j) &lt;= w[i]) dp[i][j] = i;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到某个数的最高位</span></span><br><span class="line">    <span class="keyword">auto</span> find = [&amp;] (<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">30</span>;i++) <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i) &amp; x) ans = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> now = n + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> posmax = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (posmax == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> pos = dp[now - <span class="number">1</span>][posmax];</span><br><span class="line">            <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line">                now = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 相等元素异或为 0 而任意数和 0 异或为本身所以重叠部分可以消掉</span></span><br><span class="line">            x ^= (pre[now - <span class="number">1</span>] ^ pre[pos]);</span><br><span class="line">            <span class="keyword">if</span> (x  &lt; w[pos]) &#123;</span><br><span class="line">                now = pos + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            x ^= w[pos];</span><br><span class="line">            now = pos;</span><br><span class="line">            posmax = <span class="built_in">find</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; n + <span class="number">1</span> - now &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>






]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常见注解汇总</title>
    <url>/2025/02/12/Java%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>前言 </summary>
              <div class='content'>
              <p>寒假在写算法的同时也在看Spring, 因为之前并没有学过Java所以即使有语言基础但是对于注解全然不知, 所以打算在这里写一篇汇总.</p><p>后续有空了打算将Java自带的注解和Spring等补充上来, 估计应该是开学到学校后才会来写了.</p><p>2025&#x2F;2&#x2F;24<br>开始是抄了一些别人写好的, 但是写了半小时后觉得不太好于是删了, 但是我没那么多时间整理, 所以决定后面遇到一个记录一个……</p>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Spring </summary>
              <div class='content'>
              <p>Spring-Mvc</p><ul><li><p>@Controller 将类标明为控制器</p></li><li><p>@RequestParam 主要是用来接收数据, 它可以直接接收参数 (@RequestParam String id), 也可以接收指定名字的参数 (@RequestParam(name &#x3D; “id”) String fooId)</p></li><li><p>当然他也支持接收一大堆数据, 类, List等; 但是通常是接收来自requestHeader中, 即请求头, 所以主要用于GET请求</p></li><li><p>同时该参数默认写入的参数名字是存在的(True), 如果不存在则会报错, 但是我们可以修改(False), 此时如果不存在则为 NULL</p></li><li><p>@RequestBody 接收来自requestBody请求体中的数据比如: application&#x2F;json、application&#x2F;xml、applicatioin&#x2F;x-www-form-urlencoded等类型的数据, 基本和@RequestParam一致。</p></li><li><p>@Controller 标记控制器, 将控制器交给 Spring 容器管理</p></li><li><p>@RequestMapping 给控制器方法设置请求路径, 放在方法或类上方。用于类上，表示类中的所有控制器方法都是以该地址作为父路径。</p></li><li><p>也可以单独使用指定的Mapping 如: @GetMapping()、@PostMapping()、@PutMapping()</p></li><li><p>@ModelAttribute 作用1: 设置指定方法在控制器其他方法前执行, 位置在方法上方; 作用2: 从Model模型中获取数据给参数赋值, 位置在方法参数前</p></li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">// 作用1</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/~&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerTest</span> &#123;</span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作用2</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/~&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController6</span> &#123;</span><br><span class="line">    <span class="comment">// 前置方法向Model中设置数据</span></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">       model.addAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该参数不是从请求中获取，而是从Model中获取</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/~&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Test</span><span class="params">(<span class="meta">@ModelAttribute(&quot;name&quot;)</span> String name)</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">return</span> ~;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><p>@ResponseBody 方法返回的对象转换为 JSON 格式, 放在某个方法上边, 可以将返回的对象类型转换为 JSON 格式</p></li><li><p>@RestController 如果每个返回对象都为 JSON 格式, 可以在类上边加上该注解, 可以省略 @ResponseBody</p></li><li><p>@ControllerAdvice 根据所给规则拦截控制器, 不写则默认拦截所有控制器, 可搭配 @ExceptionHandler 实现全局控制器异常处理</p></li><li><p>@ExceptionHandler 加在方法上, 表示该方法是处理异常的方法，属性为处理的异常类</p></li></ul>
              </div>
            </details>
]]></content>
      <categories>
        <category>开发</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces998(Div3 A-E)</title>
    <url>/2025/02/09/Codeforces998/</url>
    <content><![CDATA[<h3 id="A-Fibonacciness"><a href="#A-Fibonacciness" class="headerlink" title="A. Fibonacciness"></a>A. Fibonacciness</h3><p>​<br>题目链接:<a class="link"   href="https://codeforces.com/contest/2060/problem/A" >https://codeforces.com/contest/2060/problem/A<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>​处于前面位置不用多想直接暴力写</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c,d;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">    mp[a + b]++;</span><br><span class="line">    mp[c - b]++;</span><br><span class="line">    mp[d - c]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [c,v] : mp) ans = <span class="built_in">max</span>(ans, v);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="B-Farmer-John’s-Card-Game"><a href="#B-Farmer-John’s-Card-Game" class="headerlink" title="B. Farmer John’s Card Game"></a>B. Farmer John’s Card Game</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2033/problem/B" >https://codeforces.com/contest/2033/problem/B<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>首先我们要思考什么情况下有解？我们把整体想成一个二维数组，要想使得每头牛都能把牌出完,贪心的想肯定是每头牛都先出自己最小的牌。</p>
<p>首先满足的条件是对于每一列的数据必须按照同一个排序方式(出牌方式);</p>
<p>同时根据题意，如果能把牌放到堆顶那么当前牌的编号一定大于当前堆顶牌的编号;</p>
<p>也就是前一列的最大值一定是小于后一列的最小值的，这样的顺序出牌才能满足条件，因为数据很小，直接暴力排序处理即可。</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">v</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) cin&gt;&gt;v[i][j];</span><br><span class="line">        <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(), v[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">    <span class="type">int</span> next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">        vector&lt;PII&gt;sen;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) sen.<span class="built_in">emplace_back</span>(v[i][j], i);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(sen.<span class="built_in">begin</span>(), sen.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!j) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : sen) ans.<span class="built_in">emplace_back</span>(c.second);</span><br><span class="line">            next = sen[n - <span class="number">1</span>].first;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; n;k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(sen[k].second != ans[k] || sen[k].first &lt;= next) &#123;</span><br><span class="line">                    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                next = sen[k].first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : ans) cout&lt;&lt;c + <span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="C-Game-of-Mathletes"><a href="#C-Game-of-Mathletes" class="headerlink" title="C. Game of Mathletes"></a>C. Game of Mathletes</h3><p>​<br>题目链接:<a class="link"   href="https://codeforces.com/contest/2060/problem/C" >https://codeforces.com/contest/2060/problem/C<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>​初看好像是道博弈题，但是仔细想想后发现</p>
<p>因为Alice先手，所以如果Alice所选的数和数组中其它某个数能组成k那么后手的Bob是一定能够获得这1分的。</p>
<p>这样本题就和博弈无关了，我们只要统计整个数组中有多少对数之和等于k即可</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v</span>(n + <span class="number">1</span>);</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        cin&gt;&gt;v[i];</span><br><span class="line">        mp[v[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [c,v] : mp) &#123;</span><br><span class="line">        <span class="type">int</span> sen = k - c;</span><br><span class="line">        <span class="keyword">if</span>(sen == c) &#123;</span><br><span class="line">            ans += v / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(mp[sen]) &#123;</span><br><span class="line">            <span class="type">int</span> mi = <span class="built_in">min</span>(mp[sen], mp[c]);</span><br><span class="line">            ans += mi;</span><br><span class="line">            mp[sen] -= mi;</span><br><span class="line">            mp[c] -= mi;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="D-Subtract-Min-Sort"><a href="#D-Subtract-Min-Sort" class="headerlink" title="D. Subtract Min Sort"></a>D. Subtract Min Sort</h3><p>​<br>题目链接:<a class="link"   href="https://codeforces.com/contest/2060/problem/D" >https://codeforces.com/contest/2060/problem/D<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>​对于任意一个 i 我们只能处理后一个数也就是 i + 1;</p>
<p>所以假设存在第 i 个数是大于第 i + 1 个数，那个很明显无解，所以我们就顺着这个方向去模拟即可</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin&gt;&gt;v[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i] &gt; v[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v[i + <span class="number">1</span>] -= v[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="E-Graph-Composition"><a href="#E-Graph-Composition" class="headerlink" title="E. Graph Composition"></a>E. Graph Composition</h3><p>​<br>题目链接:<a class="link"   href="https://codeforces.com/contest/2060/problem/E" >https://codeforces.com/contest/2060/problem/E<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>​首先题目大意是,我们有两个图F,G,二者顶点数相同但是连边情况不一定相同;</p>
<p>我们可以对图F操作,连通的点我们可以断开,未连通的点可以连接起来,现在求使得两个图连边情况一致的最小操作次数。</p>
<p>我们直接根据题意模拟即可，分别计算出F需要断开的边数和需要连通的边数，可能需要注意的是无向图，连边会计算两次的情况。</p>
<p>可以使用并查集或者直接dfs</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m1,m2;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m1&gt;&gt;m2;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;edge1[n + <span class="number">1</span>],edge2[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m1;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge1[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        edge1[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m2;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge2[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        edge2[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt2 = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">st2</span>(n + <span class="number">1</span>);</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs2 = [&amp;](<span class="type">int</span> u) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">        adj[u] = cnt2;</span><br><span class="line">        st2[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : edge2[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st2[c]) <span class="built_in">dfs2</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st2[i]) &#123;</span><br><span class="line">            cnt2++;</span><br><span class="line">            <span class="built_in">dfs2</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    map&lt;PII, <span class="type">int</span>&gt;mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : edge1[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(adj[i] != adj[c]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                mp[&#123;i, c&#125;] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">st1</span>(n + <span class="number">1</span>);</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs1 = [&amp;](<span class="type">int</span> u) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">        st1[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : edge1[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st1[c] &amp;&amp; !mp[&#123;u, c&#125;]) <span class="built_in">dfs1</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st1[i]) &#123;</span><br><span class="line">            cnt1++;</span><br><span class="line">            <span class="built_in">dfs1</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = res / <span class="number">2</span> + (cnt1 - cnt2);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces981(Div3 A-F)</title>
    <url>/2025/02/09/Codeforces981/</url>
    <content><![CDATA[<h3 id="A-Sakurako-and-Kosuke"><a href="#A-Sakurako-and-Kosuke" class="headerlink" title="A. Sakurako and Kosuke"></a>A. Sakurako and Kosuke</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2033/problem/A" >https://codeforces.com/contest/2033/problem/A<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>樱子和浩介决定在坐标线上玩一些游戏。当前点的位置在 x&#x3D;0。他们将轮流进行，而 樱子将是第一个开始的人。</p>
<p>在第 i 次移动中，当前玩家将把点移动 2⋅i−1 个单位。樱子总是将点向负方向移动，而浩介总是向正方向移动。</p>
<p>换句话说，以下情况将发生：</p>
<ul>
<li>1.樱子将把点的位置改变 −1,现在是 x&#x3D;−1</li>
<li>2.浩介将把点的位置改变 3,现在是 x&#x3D;2</li>
<li>3.樱子将把点的位置改变 −5,现在是 x&#x3D;−3</li>
<li>⋯⋯</li>
</ul>
<p>他们将继续游戏，直到点的坐标的绝对值不超过 n。更正式地说，游戏在 −n≤x≤n 时继续。可以证明游戏总会结束。</p>
<p>你的任务是确定谁将是最后一个出手的人。</p>
<p>输入</p>
<p>第一行包含一个整数 t (1≤t≤100) — 樱子和浩介玩的游戏数量。</p>
<p>每个游戏由一个数字 n (1≤n≤100) — 定义游戏结束条件的数字描述。</p>
<p>输出</p>
<p>对于每个 t 个游戏，输出一行该游戏的结果。如果樱子是最后一个出手的人，输出 “樱子”（不带引号）；否则输出 “浩介”。</p>
<p>思路：直接模拟即可，我们维护一个当前位置，当超过正负n时退出即可，但是注意n最大为100，我记得当i &#x3D;&#x3D; 101时才会超出</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> sen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">300</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span>) sen -= (i * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> sen += (i * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(sen) &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span>) cout&lt;&lt;<span class="string">&quot;Sakurako\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Kosuke\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="B-Sakurako-and-Water"><a href="#B-Sakurako-and-Water" class="headerlink" title="B. Sakurako and Water"></a>B. Sakurako and Water</h3><p>​<br>题目链接:<a class="link"   href="https://codeforces.com/contest/2033/problem/B" >https://codeforces.com/contest/2033/problem/B<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>​在与光介的旅程中，咲良子和光介发现了一个可以表示为大小为 n×n 的矩阵的山谷，其中在 i 行和 j 列的交点上有一座高度为 a[i][j]​ 的山。</p>
<p>如果 a[i][j]&lt;0，那么那里就有一个湖。</p>
<p>光介非常害怕水，所以咲良子需要帮助他：</p>
<p>她可以用魔法选择一个方形的山脉区域，并将该区域主对角线上的每座山的高度增加一个单位。</p>
<p>更正式地说，她可以选择一个子矩阵，其左上角位于 (i,j)，右下角位于 (p,q)，使得 p−i&#x3D;q−j。</p>
<p>然后，她可以将每个位于 (i+k) 行和 (j+k) 列交点的元素加一，对于所有 k 使得 0≤k≤p−i。</p>
<p>确定咲良子必须使用魔法的最小次数，以确保没有湖泊。</p>
<p>思路：这个题最开始题目描述写的依托，看半天读不懂，后来改了题面。</p>
<p>大概就是我们可以选择一个正方形，每次操作只能把这个正方形的主对角线加1。</p>
<p>因为是只能取正方形主对角线，所以我们直接从整个矩阵的左下角往右上角取，或者反过来也行，</p>
<p>记录一下每条对角线的最小值，加到答案即可。</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">XJT___solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">v</span>(n + <span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++) cin&gt;&gt;v[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = n;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mi = INF;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x;i &lt;= n;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            mi = <span class="built_in">min</span>(mi,v[i][y]);</span><br><span class="line">            y++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mi &lt; <span class="number">0</span>) ans += <span class="built_in">abs</span>(mi);</span><br><span class="line"></span><br><span class="line">        x--;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mi = INF;</span><br><span class="line">        <span class="type">int</span> y = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x;i &gt;= <span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            mi = <span class="built_in">min</span>(mi,v[i][y]);</span><br><span class="line">            y--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mi &lt; <span class="number">0</span>) ans += <span class="built_in">abs</span>(mi);</span><br><span class="line"></span><br><span class="line">        x--;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="C-Sakurako’s-Field-Trip"><a href="#C-Sakurako’s-Field-Trip" class="headerlink" title="C. Sakurako’s Field Trip"></a>C. Sakurako’s Field Trip</h3><p>​<br>题目链接:<a class="link"   href="https://codeforces.com/contest/2033/problem/C" >https://codeforces.com/contest/2033/problem/C<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>即使在大学，学生们也需要放松。这就是为什么樱子老师决定进行一次实地考察。已知所有学生将排成一行。</p>
<p>索引为 i 的学生有一个感兴趣的话题，描述为 ai​。作为老师，您希望最小化学生队列的 干扰。</p>
<p>队列的 干扰 定义为有相同感兴趣话题的相邻人数。换句话说，干扰 是满足 a[j]​&#x3D;a[j]+1​ 的索引 j(1≤j&lt;n) 的数量。</p>
<p>为了做到这一点，您可以选择索引 i (1≤i≤n) 并交换位置 i 和 n−i+1 的学生。您可以进行任意次数的交换。</p>
<p>您的任务是确定通过上述操作可以达到的最小 干扰 量。</p>
<p>思路:最吃屎的一道题，卡了很久，后来发现直接贪心当前位置和前一个位置的即可。</p>
<p>对于 i 和 i - 1以及所对应的交换位置 n - i + 1 和 n - i + 2 我们去判断一下交换是否更优，如果更优就交换。</p>
<p>下面代码是看的别人的自己重新写了一遍然后加了几个注释(自己写的那个感觉太丑)<br>​</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin&gt;&gt;v[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= (n / <span class="number">2</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1 = v[i - <span class="number">1</span>], y1 = v[n - i + <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x2 = v[i], y2 = v[n - i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res1 = (x1 == x2) + (y1 == y2); <span class="comment">// 不换位置</span></span><br><span class="line">        <span class="type">int</span> res2 = (x1 == y2) + (y1 == x2); <span class="comment">// 换位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果换位置更优则交换</span></span><br><span class="line">        <span class="comment">// 不能比较后边的，因为如果比较v[i + 1],那么当i == i + 1时，如果此时交换了会影响到v[i].</span></span><br><span class="line">        <span class="comment">// 如果非要比较i和i + 1,就得从里面往外边遍历.</span></span><br><span class="line">        <span class="keyword">if</span>(res1 &gt; res2) <span class="built_in">swap</span>(v[i], v[n - i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(v[i] == v[i - <span class="number">1</span>]) ans++;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="D-Kousuke’s-Assignment"><a href="#D-Kousuke’s-Assignment" class="headerlink" title="D. Kousuke’s Assignment"></a>D. Kousuke’s Assignment</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2033/problem/D" >https://codeforces.com/contest/2033/problem/D<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>在与樱子的一次旅行后，浩介非常害怕，因为他忘记了他的编程作业。</p>
<p>在这个作业中，老师给了他一个包含 n 个整数的数组 a，并要求他计算数组 a 中的 不重叠 段的数量，使得每个段被认为是 美丽的。</p>
<p>如果段 [l,r] 满足 a[l]​+a[l+1]​+⋯+a[r−1]​+a[r]​&#x3D;0，则该段被认为是 美丽的。</p>
<p>对于固定的数组 a，你的任务是计算最大的不重叠 美丽 段的数量。</p>
<p>思路:听说是道很典的题(我的题做的还是太少了)，我们直接用map记录那些出现过的数，每次匹配到后清空map即可;</p>
<p>但是注意某个数为0的时候一定是最优的，我们可以单独拿出来(如果不太理解可以手动模拟几个样例应该就能明白)</p>
<p>还有就是cf不要用unordered_map。。。</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">v</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin&gt;&gt;v[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt;mp;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += v[i];</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">find</span>(sum) != mp.<span class="built_in">end</span>() || sum == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            mp.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mp[sum]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="E-Sakurako-Kosuke-and-the-Permutation"><a href="#E-Sakurako-Kosuke-and-the-Permutation" class="headerlink" title="E. Sakurako, Kosuke, and the Permutation"></a>E. Sakurako, Kosuke, and the Permutation</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2033/problem/E" >https://codeforces.com/contest/2033/problem/E<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>佐仓子的考试结束了，她表现得非常出色。作为奖励，她收到了一个排列 p。光介并不完全满意，因为他未通过一门考试，没有收到礼物。</p>
<p>他决定偷偷溜进她的房间（多亏了她锁的密码）并破坏这个排列，使其变得 简单。</p>
<p>一个排列 p 被认为是 简单 的，如果对于每个 i (1≤i≤n)，以下条件之一成立：</p>
<ul>
<li>p[i]&#x3D;i</li>
<li>p[p[i]]&#x3D;i</li>
</ul>
<p>例如，排列 [1,2,3,4]、[5,2,4,3,1] 和 [2,1] 是 简单 的，而 [2,3,1] 和 [5,2,1,4,3] 不是。</p>
<p>在一次操作中，光介可以选择索引 i,j (1≤i,j≤n) 并交换元素 p[i]​ 和 p[j]​。</p>
<p>佐仓子即将回家。你的任务是计算光介需要执行的最小操作次数，以使排列变得简单。</p>
<p>思路:题意是对于那个排列每一个位置的数都需要满足上面条件的其中一个，听说也是一道很典的题;</p>
<p>我们直接暴力找环，然后对答案的贡献就是这个环的个数减一除二 ((cnt - 1) &#x2F; 2)。</p>
<p>不会证明，但是模拟了样例之后发现就是这个。</p>
<p>还有一种思路是我们可以开两个数组，一个存 下标-&gt;值，一个存 值-&gt;下标，然后跑一遍，如果不满足就交换两个数组的值。</p>
<p>下面是找环的代码</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin&gt;&gt;v[i];</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">st</span>(n,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="type">int</span> sen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(st[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st[j] = <span class="number">1</span>;</span><br><span class="line">                j = v[j] - <span class="number">1</span>;</span><br><span class="line">                sen++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans += (sen - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>​</p>
<h3 id="F-Kosuke’s-Sloth"><a href="#F-Kosuke’s-Sloth" class="headerlink" title="F. Kosuke’s Sloth"></a>F. Kosuke’s Sloth</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2033/problem/F" >https://codeforces.com/contest/2033/problem/F<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>小笠原太懒了。他不会给你任何说明，只给你任务：</p>
<p>斐波那契数列定义如下：</p>
<ul>
<li>f(1)&#x3D;f(2)&#x3D;1.</li>
<li>f(n)&#x3D;f(n−1)+f(n−2) (3≤n)</li>
</ul>
<p>我们用 G(n,k) 表示第 n 个可被 k 整除的斐波那契数的索引。给定 n 和 k，计算 G(n,k)。</p>
<p>由于这个数字可能太大，请输出它对 1e9+7 取模的结果。</p>
<p>例如：G(3,2)&#x3D;9 因为第 3 个可被 2 整除的斐波那契数是 34。 [1,1,2,3,5,8,13,21,34]。</p>
<p>输入<br>输入数据的第一行包含一个整数 t (1≤t≤1e4) — 测试用例的数量。</p>
<p>第一行也是唯一一行包含两个整数 n 和 k (1≤n≤1e18, 1≤k≤1e5)。</p>
<p>保证所有测试用例中 k 的总和不超过 1e6。</p>
<p>输出<br>对于每个测试用例，输出唯一的数字：值 G(n,k) 对 109+7 取模的结果。</p>
<p>思路:其实简单看题后我们就能发现，本题的解法就是在斐波那契数列中找到第一个能被k整除的数然后乘以n就行了。但是问题在于如何找到这个数。一个很直接的想法，我们直接暴力枚举不就好了？但是问题又来了，我们怎么知道是否能在时间范围内枚举到第一个被k整除的数？</p>
<p>一个数学结论:斐波那契数列在模p的条件下,他的循环节最大不会超过6p</p>
<p>这是大佬的证明:<a class="link"   href="https://www.cnblogs.com/wlzhouzhuan/p/13901190.html" >https://www.cnblogs.com/wlzhouzhuan/p/13901190.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>在本题下，k最大为1e5,也就是说在理论最坏情况下会跑 6e5的样子，不算很大的数，所以我们就可以直接枚举了。</p>
<p>​<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll fib[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    fib[<span class="number">1</span>] = <span class="number">1</span>,fib[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fib[sign] = (fib[sign - <span class="number">1</span>] + fib[sign - <span class="number">2</span>]) % k;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!fib[sign]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        sign++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(n % mod) * sign % mod&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<h3 id="G-Sakurako-and-Chefir"><a href="#G-Sakurako-and-Chefir" class="headerlink" title="G. Sakurako and Chefir"></a>G. Sakurako and Chefir</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2033/problem/G" >https://codeforces.com/contest/2033/problem/G<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
</search>
