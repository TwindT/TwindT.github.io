<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Codeforces981(A-F)</title>
    <url>/2025/02/09/Codeforces981/</url>
    <content><![CDATA[<h3 id="A-Sakurako-and-Kosuke"><a href="#A-Sakurako-and-Kosuke" class="headerlink" title="A. Sakurako and Kosuke"></a>A. Sakurako and Kosuke</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2033/problem/A" >https://codeforces.com/contest/2033/problem/A<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>樱子和浩介决定在坐标线上玩一些游戏。当前点的位置在 x&#x3D;0。他们将轮流进行，而 樱子将是第一个开始的人。</p>
<p>在第 i 次移动中，当前玩家将把点移动 2⋅i−1 个单位。樱子总是将点向负方向移动，而浩介总是向正方向移动。</p>
<p>换句话说，以下情况将发生：</p>
<ul>
<li>1.樱子将把点的位置改变 −1,现在是 x&#x3D;−1</li>
<li>2.浩介将把点的位置改变 3,现在是 x&#x3D;2</li>
<li>3.樱子将把点的位置改变 −5,现在是 x&#x3D;−3</li>
<li>⋯⋯</li>
</ul>
<p>他们将继续游戏，直到点的坐标的绝对值不超过 n。更正式地说，游戏在 −n≤x≤n 时继续。可以证明游戏总会结束。</p>
<p>你的任务是确定谁将是最后一个出手的人。</p>
<p>输入</p>
<p>第一行包含一个整数 t (1≤t≤100) — 樱子和浩介玩的游戏数量。</p>
<p>每个游戏由一个数字 n (1≤n≤100) — 定义游戏结束条件的数字描述。</p>
<p>输出</p>
<p>对于每个 t 个游戏，输出一行该游戏的结果。如果樱子是最后一个出手的人，输出 “樱子”（不带引号）；否则输出 “浩介”。</p>
<p>思路：直接模拟即可，我们维护一个当前位置，当超过正负n时退出即可，但是注意n最大为100，我记得当i &#x3D;&#x3D; 101时才会超出</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> sen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">300</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span>) sen -= (i * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> sen += (i * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(sen) &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span>) cout&lt;&lt;<span class="string">&quot;Sakurako\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Kosuke\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="B-Sakurako-and-Water"><a href="#B-Sakurako-and-Water" class="headerlink" title="B. Sakurako and Water"></a>B. Sakurako and Water</h3><p>​<br>题目链接:<a class="link"   href="https://codeforces.com/contest/2033/problem/B" >https://codeforces.com/contest/2033/problem/B<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>​在与光介的旅程中，咲良子和光介发现了一个可以表示为大小为 n×n 的矩阵的山谷，其中在 i 行和 j 列的交点上有一座高度为 a[i][j]​ 的山。</p>
<p>如果 a[i][j]&lt;0，那么那里就有一个湖。</p>
<p>光介非常害怕水，所以咲良子需要帮助他：</p>
<p>她可以用魔法选择一个方形的山脉区域，并将该区域主对角线上的每座山的高度增加一个单位。</p>
<p>更正式地说，她可以选择一个子矩阵，其左上角位于 (i,j)，右下角位于 (p,q)，使得 p−i&#x3D;q−j。</p>
<p>然后，她可以将每个位于 (i+k) 行和 (j+k) 列交点的元素加一，对于所有 k 使得 0≤k≤p−i。</p>
<p>确定咲良子必须使用魔法的最小次数，以确保没有湖泊。</p>
<p>思路：这个题最开始题目描述写的依托，看半天读不懂，后来改了题面。</p>
<p>大概就是我们可以选择一个正方形，每次操作只能把这个正方形的主对角线加1。</p>
<p>因为是只能取正方形主对角线，所以我们直接从整个矩阵的左下角往右上角取，或者反过来也行，</p>
<p>记录一下每条对角线的最小值，加到答案即可。</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">XJT___solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">v</span>(n + <span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++) cin&gt;&gt;v[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = n;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mi = INF;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x;i &lt;= n;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            mi = <span class="built_in">min</span>(mi,v[i][y]);</span><br><span class="line">            y++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mi &lt; <span class="number">0</span>) ans += <span class="built_in">abs</span>(mi);</span><br><span class="line"></span><br><span class="line">        x--;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mi = INF;</span><br><span class="line">        <span class="type">int</span> y = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x;i &gt;= <span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            mi = <span class="built_in">min</span>(mi,v[i][y]);</span><br><span class="line">            y--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mi &lt; <span class="number">0</span>) ans += <span class="built_in">abs</span>(mi);</span><br><span class="line"></span><br><span class="line">        x--;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="C-Sakurako’s-Field-Trip"><a href="#C-Sakurako’s-Field-Trip" class="headerlink" title="C. Sakurako’s Field Trip"></a>C. Sakurako’s Field Trip</h3><p>​<br>题目链接:<a class="link"   href="https://codeforces.com/contest/2033/problem/C" >https://codeforces.com/contest/2033/problem/C<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>即使在大学，学生们也需要放松。这就是为什么樱子老师决定进行一次实地考察。已知所有学生将排成一行。</p>
<p>索引为 i 的学生有一个感兴趣的话题，描述为 ai​。作为老师，您希望最小化学生队列的 干扰。</p>
<p>队列的 干扰 定义为有相同感兴趣话题的相邻人数。换句话说，干扰 是满足 a[j]​&#x3D;a[j]+1​ 的索引 j(1≤j&lt;n) 的数量。</p>
<p>为了做到这一点，您可以选择索引 i (1≤i≤n) 并交换位置 i 和 n−i+1 的学生。您可以进行任意次数的交换。</p>
<p>您的任务是确定通过上述操作可以达到的最小 干扰 量。</p>
<p>思路:最吃屎的一道题，卡了很久，后来发现直接贪心当前位置和前一个位置的即可。</p>
<p>对于 i 和 i - 1以及所对应的交换位置 n - i + 1 和 n - i + 2 我们去判断一下交换是否更优，如果更优就交换。</p>
<p>下面代码是看的别人的自己重新写了一遍然后加了几个注释(自己写的那个感觉太丑)<br>​</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin&gt;&gt;v[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= (n / <span class="number">2</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1 = v[i - <span class="number">1</span>], y1 = v[n - i + <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x2 = v[i], y2 = v[n - i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res1 = (x1 == x2) + (y1 == y2); <span class="comment">// 不换位置</span></span><br><span class="line">        <span class="type">int</span> res2 = (x1 == y2) + (y1 == x2); <span class="comment">// 换位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果换位置更优则交换</span></span><br><span class="line">        <span class="comment">// 不能比较后边的，因为如果比较v[i + 1],那么当i == i + 1时，如果此时交换了会影响到v[i].</span></span><br><span class="line">        <span class="comment">// 如果非要比较i和i + 1,就得从里面往外边遍历.</span></span><br><span class="line">        <span class="keyword">if</span>(res1 &gt; res2) <span class="built_in">swap</span>(v[i], v[n - i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(v[i] == v[i - <span class="number">1</span>]) ans++;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="D-Kousuke’s-Assignment"><a href="#D-Kousuke’s-Assignment" class="headerlink" title="D. Kousuke’s Assignment"></a>D. Kousuke’s Assignment</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2033/problem/D" >https://codeforces.com/contest/2033/problem/D<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>在与樱子的一次旅行后，浩介非常害怕，因为他忘记了他的编程作业。</p>
<p>在这个作业中，老师给了他一个包含 n 个整数的数组 a，并要求他计算数组 a 中的 不重叠 段的数量，使得每个段被认为是 美丽的。</p>
<p>如果段 [l,r] 满足 a[l]​+a[l+1]​+⋯+a[r−1]​+a[r]​&#x3D;0，则该段被认为是 美丽的。</p>
<p>对于固定的数组 a，你的任务是计算最大的不重叠 美丽 段的数量。</p>
<p>思路:听说是道很典的题(我的题做的还是太少了)，我们直接用map记录那些出现过的数，每次匹配到后清空map即可;</p>
<p>但是注意某个数为0的时候一定是最优的，我们可以单独拿出来(如果不太理解可以手动模拟几个样例应该就能明白)</p>
<p>还有就是cf不要用unordered_map。。。</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">v</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin&gt;&gt;v[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt;mp;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += v[i];</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">find</span>(sum) != mp.<span class="built_in">end</span>() || sum == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            mp.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mp[sum]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="E-Sakurako-Kosuke-and-the-Permutation"><a href="#E-Sakurako-Kosuke-and-the-Permutation" class="headerlink" title="E. Sakurako, Kosuke, and the Permutation"></a>E. Sakurako, Kosuke, and the Permutation</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2033/problem/E" >https://codeforces.com/contest/2033/problem/E<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>佐仓子的考试结束了，她表现得非常出色。作为奖励，她收到了一个排列 p。光介并不完全满意，因为他未通过一门考试，没有收到礼物。</p>
<p>他决定偷偷溜进她的房间（多亏了她锁的密码）并破坏这个排列，使其变得 简单。</p>
<p>一个排列 p 被认为是 简单 的，如果对于每个 i (1≤i≤n)，以下条件之一成立：</p>
<ul>
<li>p[i]&#x3D;i</li>
<li>p[p[i]]&#x3D;i</li>
</ul>
<p>例如，排列 [1,2,3,4]、[5,2,4,3,1] 和 [2,1] 是 简单 的，而 [2,3,1] 和 [5,2,1,4,3] 不是。</p>
<p>在一次操作中，光介可以选择索引 i,j (1≤i,j≤n) 并交换元素 p[i]​ 和 p[j]​。</p>
<p>佐仓子即将回家。你的任务是计算光介需要执行的最小操作次数，以使排列变得简单。</p>
<p>思路:题意是对于那个排列每一个位置的数都需要满足上面条件的其中一个，听说也是一道很典的题;</p>
<p>我们直接暴力找环，然后对答案的贡献就是这个环的个数减一除二 ((cnt - 1) &#x2F; 2)。</p>
<p>不会证明，但是模拟了样例之后发现就是这个。</p>
<p>还有一种思路是我们可以开两个数组，一个存 下标-&gt;值，一个存 值-&gt;下标，然后跑一遍，如果不满足就交换两个数组的值。</p>
<p>下面是找环的代码</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin&gt;&gt;v[i];</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">st</span>(n,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="type">int</span> sen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(st[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st[j] = <span class="number">1</span>;</span><br><span class="line">                j = v[j] - <span class="number">1</span>;</span><br><span class="line">                sen++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans += (sen - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>​</p>
<h3 id="F-Kosuke’s-Sloth"><a href="#F-Kosuke’s-Sloth" class="headerlink" title="F. Kosuke’s Sloth"></a>F. Kosuke’s Sloth</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2033/problem/F" >https://codeforces.com/contest/2033/problem/F<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>小笠原太懒了。他不会给你任何说明，只给你任务：</p>
<p>斐波那契数列定义如下：</p>
<ul>
<li>f(1)&#x3D;f(2)&#x3D;1.</li>
<li>f(n)&#x3D;f(n−1)+f(n−2) (3≤n)</li>
</ul>
<p>我们用 G(n,k) 表示第 n 个可被 k 整除的斐波那契数的索引。给定 n 和 k，计算 G(n,k)。</p>
<p>由于这个数字可能太大，请输出它对 1e9+7 取模的结果。</p>
<p>例如：G(3,2)&#x3D;9 因为第 3 个可被 2 整除的斐波那契数是 34。 [1,1,2,3,5,8,13,21,34]。</p>
<p>输入<br>输入数据的第一行包含一个整数 t (1≤t≤1e4) — 测试用例的数量。</p>
<p>第一行也是唯一一行包含两个整数 n 和 k (1≤n≤1e18, 1≤k≤1e5)。</p>
<p>保证所有测试用例中 k 的总和不超过 1e6。</p>
<p>输出<br>对于每个测试用例，输出唯一的数字：值 G(n,k) 对 109+7 取模的结果。</p>
<p>思路:其实简单看题后我们就能发现，本题的解法就是在斐波那契数列中找到第一个能被k整除的数然后乘以n就行了。但是问题在于如何找到这个数。一个很直接的想法，我们直接暴力枚举不就好了？但是问题又来了，我们怎么知道是否能在时间范围内枚举到第一个被k整除的数？</p>
<p>一个数学结论:斐波那契数列在模p的条件下,他的循环节最大不会超过6p</p>
<p>这是大佬的证明:<a class="link"   href="https://www.cnblogs.com/wlzhouzhuan/p/13901190.html" >https://www.cnblogs.com/wlzhouzhuan/p/13901190.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>在本题下，k最大为1e5,也就是说在理论最坏情况下会跑 6e5的样子，不算很大的数，所以我们就可以直接枚举了。</p>
<p>​<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll fib[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    fib[<span class="number">1</span>] = <span class="number">1</span>,fib[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fib[sign] = (fib[sign - <span class="number">1</span>] + fib[sign - <span class="number">2</span>]) % k;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!fib[sign]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        sign++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(n % mod) * sign % mod&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<h3 id="G-Sakurako-and-Chefir"><a href="#G-Sakurako-and-Chefir" class="headerlink" title="G. Sakurako and Chefir"></a>G. Sakurako and Chefir</h3><p>题目链接:<a class="link"   href="https://codeforces.com/contest/2033/problem/G" >https://codeforces.com/contest/2033/problem/G<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
